import OpenAI from 'openai'

// Inizializza il client OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})

/**
 * Trascrive un file audio utilizzando OpenAI Whisper
 * @param audioBuffer - Buffer del file audio
 * @param fileName - Nome del file audio per l'API
 * @returns Promise<string> - Il testo trascritto
 */
export async function transcribeAudio(audioBuffer: Buffer, fileName: string): Promise<string> {
  try {
    if (!process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY === 'sk-your-openai-api-key-here') {
      throw new Error('OPENAI_API_KEY not configured or invalid')
    }

    console.log(`Starting transcription for file: ${fileName}`)
    
    // Crea un File object dal buffer
    const audioFile = new File([audioBuffer], fileName, { 
      type: 'audio/mpeg' // Tipo generico per audio
    })
    
    // Chiama l'API Whisper di OpenAI
    const transcription = await openai.audio.transcriptions.create({
      file: audioFile,
      model: 'whisper-1',
      language: 'it', // Italiano
      response_format: 'verbose_json', // Più dettagli nella risposta
      temperature: 0.0, // Massima accuratezza
      prompt: "Trascrivi accuratamente tutto il parlato in italiano. Ignora rumori di fondo, musiche o watermark."
    })

    console.log('Trascrizione completata con successo')
    console.log('Dettagli trascrizione:', {
      text: transcription.text?.substring(0, 100) + '...',
      language: transcription.language,
      duration: transcription.duration
    })
    
    return transcription.text || String(transcription)

  } catch (error) {
    console.error('Errore durante la trascrizione:', error)
    
    // Gestione di errori specifici
    if (error instanceof Error) {
      if (error.message.includes('rate limit')) {
        throw new Error('OpenAI rate limit reached. Please try again in a few minutes.')
      }
      if (error.message.includes('insufficient_quota')) {
        throw new Error('OpenAI quota exceeded. Please check your OpenAI account.')
      }
      if (error.message.includes('invalid_api_key')) {
        throw new Error('Invalid OpenAI API key. Please check your configuration.')
      }
    }
    
    throw new Error(`Error during transcription: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

/**
 * Analizza un testo trascritto utilizzando GPT per estrarre insights terapeutici
 * @param transcript - Il testo trascritto da analizzare
 * @param sessionTitle - Titolo della sessione per contesto
 * @returns Promise<string> - L'analisi del testo
 */
export async function analyzeTranscript(transcript: string, sessionTitle: string): Promise<string> {
  try {
    if (!process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY === 'sk-your-openai-api-key-here') {
      throw new Error('OPENAI_API_KEY not configured or invalid')
    }

    console.log(`Starting analysis for session: ${sessionTitle}`)
    
    const prompt = `
Analyze the following transcript of a therapy session and provide a structured professional analysis.

Session title: ${sessionTitle}

Transcript:
${transcript}

Provide a structured analysis that includes:

1. **MAIN THEMES**: Identify recurring themes and central issues discussed
2. **EMOTIONAL STATE**: Analysis of the patient's emotional tone and mood
3. **PROGRESS**: Any signs of progress or improvement compared to previous sessions
4. **AREAS OF ATTENTION**: Topics that require further exploration
5. **RECOMMENDATIONS**: Suggestions for upcoming sessions

Use professional and clinical language, respecting confidentiality and the sensitivity of therapeutic content.
`

    const completion = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        {
          role: 'system',
          content: 'You are an assistant specialized in the analysis of therapy sessions. Provide professional, empathetic, and clinically relevant analyses.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.3,
      max_tokens: 1500,
    })

    const analysis = completion.choices[0]?.message?.content
    if (!analysis) {
      throw new Error('No analysis generated by OpenAI')
    }

    console.log('Analysis completed successfully')
    return analysis

  } catch (error) {
    console.error('Errore durante l\'analisi:', error)
    throw new Error(`Error during analysis: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

/**
 * Diarizza una trascrizione utilizzando GPT-3.5-turbo per identificare i diversi interlocutori
 * @param transcript - Il testo trascritto da diarizzare
 * @param sessionTitle - Titolo della sessione per contesto
 * @returns Promise<string> - La trascrizione diarizzata con identificazione degli interlocutori
 */
export async function diarizeTranscript(transcript: string, sessionTitle: string): Promise<string> {
  try {
    if (!process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY === 'sk-your-openai-api-key-here') {
      throw new Error('OPENAI_API_KEY not configured or invalid')
    }

    console.log(`Starting diarization for session: ${sessionTitle}`)
    console.log(`Original transcript length: ${transcript.length} characters`)

    // Limiti modello GPT-3.5-turbo: ~16k token, ma lasciamo margine per prompt e risposta
    const MAX_CHARS_PER_CHUNK = 6000; // Sicuro per prompt + risposta
    const chunks: string[] = [];
    if (transcript.length > MAX_CHARS_PER_CHUNK) {
      // Prova a spezzare su doppio newline (paragrafi), poi su frasi
      let current = '';
      for (const paragraph of transcript.split(/\n\n+/)) {
        if ((current + '\n\n' + paragraph).length > MAX_CHARS_PER_CHUNK) {
          if (current) chunks.push(current);
          current = paragraph;
        } else {
          current = current ? current + '\n\n' + paragraph : paragraph;
        }
      }
      if (current) chunks.push(current);
      // Se ancora qualche chunk è troppo lungo, spezza su frasi
      for (let i = 0; i < chunks.length; i++) {
        if (chunks[i].length > MAX_CHARS_PER_CHUNK) {
          const sentences = chunks[i].split(/(?<=[.!?])\s+/);
          let subCurrent = '';
          const subChunks: string[] = [];
          for (const sentence of sentences) {
            if ((subCurrent + ' ' + sentence).length > MAX_CHARS_PER_CHUNK) {
              if (subCurrent) subChunks.push(subCurrent);
              subCurrent = sentence;
            } else {
              subCurrent = subCurrent ? subCurrent + ' ' + sentence : sentence;
            }
          }
          if (subCurrent) subChunks.push(subCurrent);
          // Sostituisci il chunk troppo lungo con i subchunk
          chunks.splice(i, 1, ...subChunks);
          i += subChunks.length - 1;
        }
      }
    } else {
      chunks.push(transcript);
    }

    // Prompt in italiano (come già impostato)
    const promptBase = (chunk: string) => `
Analizza la seguente trascrizione di una sessione di terapia e identifica i diversi interlocutori.

Titolo della sessione: ${sessionTitle}

Trascrizione originale:
${chunk}

Il tuo compito è identificare quanti interlocutori ci sono e chi dice cosa. Tipicamente, in una sessione di terapia ci sono:
- Il terapeuta (che devi identificare sempre come "Terapeuta:")
- Il paziente (che devi identificare sempre come "Paziente:")

Istruzioni:
1. Analizza il contenuto per individuare i cambi di interlocutore.
2. Se la trascrizione contiene già etichette, nomi o ruoli (ad esempio "Dott.ssa Rossi:", "Mario:", "Psicologo:", "T:"), sostituiscili TUTTI con solo due ruoli: "Terapeuta:" e "Paziente:". Rimuovi ogni nome, iniziale o titolo originale.
3. Se non ci sono etichette, deduci i cambi di interlocutore e assegna il ruolo corretto.
4. Riformatta la trascrizione aggiungendo sempre e solo i prefissi "Terapeuta:" o "Paziente:" prima di ogni intervento.
5. Mantieni tutto il contenuto originale, modifica solo i prefissi.
6. Usa SEMPRE e SOLO il formato "Terapeuta:" o "Paziente:" prima di ogni intervento, in italiano.
7. Ogni intervento deve essere separato da UNA SOLA riga vuota (un solo a capo tra una battuta e la successiva, senza righe doppie o triple).

Esempio di output desiderato:
Terapeuta: Buongiorno, come si sente oggi?

Paziente: Bene, grazie. Ho fatto il compito che mi ha dato.

Terapeuta: Ottimo, mi racconti com'è andata?

Restituisci SOLO la trascrizione diarizzata, senza alcun commento aggiuntivo.
`;

    let diarizedChunks: string[] = [];
    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];
      console.log(`Diarizing chunk ${i + 1}/${chunks.length} (${chunk.length} chars)`);
      const completion = await openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: 'Sei un assistente specializzato nella diarizzazione di trascrizioni di sessioni di terapia. Il tuo compito è identificare i diversi interlocutori e riformattare la trascrizione aggiungendo prefissi chiari per ogni persona che parla.'
          },
          {
            role: 'user',
            content: promptBase(chunk)
          }
        ],
        temperature: 0.1,
        max_tokens: 4000,
      });
      const diarized = completion.choices[0]?.message?.content;
      if (!diarized) {
        throw new Error('No diarized transcript generated by OpenAI for chunk ' + (i + 1));
      }
      diarizedChunks.push(diarized.trim());
    }
    const diarizedTranscript = diarizedChunks.join('\n');
    // Normalizza: un solo a capo tra ogni battuta (Terapeuta:/Paziente:)
    const normalizedTranscript = diarizedTranscript
      .replace(/\s*\n\s*/g, '\n') // elimina spazi extra attorno agli a capo
      .replace(/\n{2,}/g, '\n') // sostituisci doppi/tripli a capo con uno solo
      .replace(/(Terapeuta:|Paziente:)/g, '\n$1') // assicura che ogni battuta inizi su una nuova riga
      .replace(/^\n+/, '') // rimuovi eventuali a capo iniziali
      .replace(/\n+$/, ''); // rimuovi eventuali a capo finali
    console.log('Diarization completed successfully');
    console.log(`Diarized transcript length: ${normalizedTranscript.length} characters`);
    return normalizedTranscript;
  } catch (error) {
    console.error('Errore durante la diarizzazione:', error);
    throw new Error(`Error during diarization: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}
